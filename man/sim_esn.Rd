% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sim_esn.R
\name{sim_esn}
\alias{sim_esn}
\title{Simulate data from an ESN model}
\usage{
sim_esn(
  x,
  t,
  tau,
  m,
  tau_emb,
  nh,
  V,
  sigma2,
  W,
  U,
  nu,
  add_quad,
  internal_scaling = "none",
  y_mean = NULL,
  y_sd = NULL
)
}
\arguments{
\item{x}{Matrix of training data inputs with T rows (number of times) and 
P columns (number of input variables) - Note: rows must be ordered 
top to bottom from earliest to latest observation)}

\item{t}{Vector containing times/dates associated with x matrix}

\item{tau}{Forecast lead time}

\item{m}{Embedding vector length}

\item{tau_emb}{Embedding lag}

\item{nh}{Number of hidden units}

\item{V}{Ridge regression parameter matrix}

\item{sigma2}{Ridge regression error variance}

\item{W}{W matrix in hidden stage}

\item{U}{U matrix in hidden stage}

\item{nu}{Scaling parameter for W}

\item{add_quad}{Indicates whether to add a quadratic term to the ridge
regression}

\item{internal_scaling}{Specifies the type of standardization that should be 
applied internally to x and y. This is common in ESN literature.
Options are "joint" (the mean and standard deviation from all values 
in the x/y matrix are computed after appropriate times are removed
and used to center and scale the values in the x/y matrix) and "none"
(no internal scaling is applied). Default is "none". It is best to 
only use internal scaling if the model parameters were obtained by
first training a model using fit_esn'.}

\item{y_mean}{If internal_scaling is 'joint', mean value of y used for 
scaling.}

\item{y_sd}{If internal_scaling is 'joint', standard deviation of y used 
for scaling.}
}
\description{
Function for simulating data from an ESN model.
}
\examples{
# Extract data times
x_sim = sim$x_stdzd
t_sim = sort(unique(sim$time))

# Prepare training data matrices for ESN:
library(dplyr)
prep_mat_sim <- function(var_name) {
  var_name = paste0(var_name, "_stdzd")
  sim \%>\%
    select(easting, northing, time, all_of(var_name)) \%>\%
     tidyr::pivot_wider(
      id_cols = c(easting, northing),
      names_from = time,
      values_from = all_of(var_name)
     ) \%>\%
   select(-easting, -northing) \%>\%
   t()
 }
 sim_mats <- purrr::set_names(c("y", "x")) \%>\% purrr::map(.f = prep_mat_sim)
 
 # Compute EOFs
 n_eofs = 5
 sim_eofs = purrr::map(.x = sim_mats, .f = compute_eofs, n_eofs = n_eofs)
 
 # Specify model inputs/outputs
 x_sim = cbind(sim_eofs$x$train)
 y_sim = sim_eofs$y$train
 
 # Fit ESN
 esn <-
  fit_esn(
    x = x_sim,
    y = y_sim,
    t = as.character(t_sim),
    tau = 1,
    m = 5,
    tau_emb = 1,
    nh = 50,
    add_quad = TRUE,
    internal_scaling = "joint",
    seed = 20230223
  )
 
 # Simulate data from ESN 
 esn_sim_dat <-
  sim_esn(
    x = x_sim,
    t = t_sim,
    tau = esn$params_tuning$tau,
    m = esn$params_tuning$m,
    tau_emb = esn$params_tuning$tau_emb,
    nh = esn$params_tuning$nh,
    V = esn$param_est$V,
    sigma2 = esn$param_est$sigma2,
    W = esn$param_est$W,
    U = esn$param_est$U,
    nu = esn$params_tuning$nu,
    add_quad = esn$add_quad
  )
}
